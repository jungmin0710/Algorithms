#다이나믹 프로그래밍 : 배열에 값을 담아둔다. 계산 결과가 필요할 때마다 배열에서 찾아 쓴다(계산 시간을 줄여줌. 피보나치 수열 참고할 것)
#점화식 : 모든 계산에 공통되는 공식! 점화식을 코드화 시키면 다이나믹 프로그래밍 문제를 해결할 수 있다.


def CaseNumber(n,m,arr):
  dp = [100001] * (m+1) #min값을 찾아야하므로 큰 수로 초기화해두기
  #index의 의미 => 'index원' 0번째는 0원, 1번째는 1원...에 해당
  #마지막 인덱스의 값이 최종적으로 판단되는 값이다!
  dp[0] = 0 #0원은 판단할 수 없으므로 무조건 값을 0으로 고정한다.
  for i in range(n):
    for j in range(arr[i],m+1): #조사할 값보다 작은 인덱스는 수정할 필요가 없다.(어차피 바꾸지 못하는 값이기 때문) 
      if dp[j-arr[i]] != 100001:#초기값이 아니면 수정된 값이므로 해당 값을 만드는 방법이 이전에 존재했다는 뜻
        dp[j] = min(dp[j],dp[j-arr[i]]+1) 
        
        #첫번째 숫자가 돌 때 금액에 맞춰 동전을 넣어둔다(맞지 않으면 초기값)
        #다음 수 차례가 오면 그 동전을 추가로 넣는다.
        #만약 다음 수 차례에 그 동전을 이용해서 더 적은 갯수로 교체가 가능하면 해당 인덱스의 값을 교체한다
        #(예를들어 2,3 순서인데 6번 인덱스라면 3개 => 2개로 값이 교체된다)
        #목표 금액인 마지막 방의 값을 출력한다
        
  
  if dp[m] == 100001: #배열 마지막 값이 초기값이면 방법이 없다는 뜻이 된다. -1반환
    return -1
  else:
    return dp[m] #배열의 마지막 값 리턴

        
  

#입력받기
n,m = list(map(int,input().split()))
arr = []
for i in range(n):
  arr.append(int(input())) 

#메서드를 호출해서 출력
x = CaseNumber(n,m,arr)
print(x)
